<context>
# Overview
Conciergus is a feature-rich, headless, unstyled React library for building AI-powered website assistants and advanced live chat experiences. It streamlines the development of intelligent chat widgets by providing extensible, unopinionated components built on top of the Vercel AI SDK and Radix UI primitives.

# Core Features
- **Headless UI**: Unstyled components using Radix UI primitives (Dialog, ScrollArea, etc.) with `className` and `...rest` props for full styling flexibility.
- **AI Chat Logic**: Leveraging `useChat` from the Vercel AI SDK for real-time streaming chat, tool integration, and system prompts.
- **Modular Components**: Chat widget container, message list with virtualization, message rendering, chat input, tool UI renderer, form renderer.
- **Advanced Interactions**: Voice chat (STT/TTS), proactive engagement triggers, human handover events, multi-language support.
- **Extensible Tooling**: Built-in support for function calling, RAG retrieval patterns, lead capture forms, simple carousels.
- **Developer Experience**: First-class TypeScript definitions, clear console errors for misconfigurations, optional context provider, plugin hooks.

# User Experience
**Target Personas**: React/Next.js developers building AI-assisted website chat experiences.
**Key User Flows**:
1. Install `@conciergus/chat` → Wrap app with `ConciergusProvider` (optional) → Import and embed `<ConciergusChatWidget />`.
2. Configure backend API endpoint for Vercel AI SDK and RAG sources.
3. Customize component styling via Tailwind CSS or CSS-in-JS by passing `className` and props.
4. Use advanced features: voice chat, tool calls, proactive triggers, human handover.
5. Monitor and debug via clear console warnings and optional exposed state.
**DX Considerations**:
- Robust TSDoc and type hints for all components and hooks.
- Example-driven documentation with code snippets.
- Console feedback during development for missing props or incorrect configurations.
- Support for tree-shaking and minimal bundle size.
</context>
<PRD>
## 1. Introduction & Vision
### 1.1 Project Name
Conciergus

### 1.2 Elevator Pitch
Conciergus is an open-source React library that lets developers embed intelligent, AI-powered website assistants and advanced live-chat experiences. Rather than being a SaaS chat application, Conciergus supplies the **building blocks** that transform the familiar live-chat widget into a highly capable business assistant.

### 1.3 Core Problem Addressed
Traditional live-chat widgets are static, operator-centric, and costly to staff. Building next-generation, AI-driven alternatives from scratch requires wiring up LLM streaming, function calling, voice support, rich-media rendering, accessibility, and design flexibility—an expensive and repetitive effort for every team.

### 1.4 Proposed Solution & Core Value Proposition
Conciergus provides a headless set of React components, hooks, and patterns—built **on top of the Vercel AI SDK** and **composed with Radix UI primitives**—that give developers:
• Knowledgeable assistants backed by Retrieval-Augmented Generation (RAG)
• Action-oriented experiences through Vercel AI SDK function calls
• Engaging multimodal UIs (voice, rich media, forms)
• Personalised, brand-aligned personalities via configurable system prompts
• Collaboration hooks such as human-handover events

### 1.5 Target Users/Audience
Front-end engineers working with React or Next.js who need to add sophisticated AI assistants to marketing sites, SaaS dashboards, documentation portals, or support centres.

### 1.6 Guiding Principles
1. **Vercel AI SDK First** – reuse its `useChat` hook and streaming utilities directly.
2. **Radix UI Foundation** – accessibility and composability out-of-the-box.
3. **Headless & Unstyled** – never impose design; always accept `className` & `...rest` props.
4. **Client-Side Only** – leave back-end logic to the implementer; provide clear examples.
5. **Developer Experience** – strong TypeScript, rich console warnings, optional debug context.

### 1.7 Licensing & Governance
- Conciergus is released under the **Apache License 2.0** and governed by the [Contributor Covenant](https://www.contributor-covenant.org/) Code of Conduct with an initial BDFL model until a broader maintainer group forms.

## 2. Core Architecture & Vercel AI SDK Integration
**2.1 Key Dependencies**

• **Peer Dependencies**  
  - `react` ^19.1.0  
  - `react-dom` ^19.1.0  

• **Direct Dependencies**  
  - `@ai-sdk/react` and `ai` – Vercel AI SDK core for streaming/chat/function-calling  
  - Radix UI primitives: `@radix-ui/react-dialog`, `@radix-ui/react-scroll-area`, `@radix-ui/react-portal`, etc.  
  - `react-textarea-autosize` – direct dependency for autosizing chat input textarea  
  - `@babel/runtime` – runtime helpers for the ESM build  
  - Markdown stack: `react-markdown`, `remark-gfm`, `rehype-sanitize`  
  - (Optional) List virtualization: `react-window`, `react-virtualized-auto-sizer` (for `<ConciergusMessageList />`)  

• **Dev / Build Tooling**  
  - TypeScript, pnpm, Rollup

**2.2 Primary Hook Usage**  
Developers will primarily use the `useChat` hook directly from `@ai-sdk/react`. Conciergus UI components seamlessly consume its returned values (`messages`, `input`, `handleInputChange`, `handleSubmit`, `isLoading`, `error`, `append`, `reload`, `stop`, `setInput`, `data`, `toolInvocations`). A thin wrapper `useConciergusChat` will **only** be introduced if essential for adapting `useChat` for Conciergus-specific UI state (e.g., advanced voice-control flags).

**2.3 ConciergusProvider (Optional Context)**  
Provides global Conciergus configuration when needed:  
- `defaultTTSVoice?: string`  
- `isTTSEnabledByDefault?: boolean`  
- `ttsApiEndpoint?: string` – custom backend TTS endpoint  
- `onTextToAudio?: (text: string) => Promise<string | Blob>` – custom backend TTS override  
- `onProcessRecordedAudio?: (blob: Blob) => Promise<string>` – custom backend STT handler  
- `proactiveRules?: ProactiveRule[]`  
- `enableDebug?: boolean`

These values are exposed via React Context for hooks/components. **Note:** The `api` endpoint for chat remains a direct prop to Vercel AI SDK's `useChat`.

**2.4 Backend Endpoint Expectation**  
The `api` prop supplied to Vercel AI SDK's `useChat` must point to a developer-implemented, Vercel AI SDK-compatible endpoint that handles streaming chat, function calls, and any RAG logic.

## 3. UI Components (Headless, Radix UI-based, v1.0 Features Included)
**General**: Components are structurally minimal and unstyled by default; styling is the developer's responsibility using `className`, `data-*`, and Radix UI `data-state` attributes. All components accept these props plus `aria-*` and `...rest`, have strictly typed callback props, and consume data from Vercel AI SDK's `useChat`. Documentation will provide styling examples with Tailwind CSS, plain CSS, and CSS-in-JS.

**3.1 `<ConciergusChatWidget />`**  
- Dialog-based container using Radix `Dialog`.  
- Props: `isOpen: boolean`, `onOpenChange: (open: boolean) => void`, `className?: string`  
- Slots: Header, Footer, Custom trigger.

**3.2 `<ConciergusMessageList />`**  
For v1.0 this component relies on `@radix-ui/react-scroll-area` for accessible, styleable scrollbars. Full list virtualization (e.g., with `react-window`) for dynamically heighted items is a stretch goal for v1.0; if not fully achievable, the library will document strategies for handling very long histories or defer full virtualization to v1.1+.

**3.3 `<ConciergusMessageItem />`**  
Renders `message.content` (Markdown) and any rich UI from `message.ui`. **Audio Playback UI:** If the Message object includes audio data (e.g., a streamed blob or URL in `message.experimental_customRenderData.audioUrl`) provided by the developer's TTS backend, this component renders controls to play, pause, or replay that audio.

**3.4 `<ConciergusChatInput />`**  
Props are wired directly to Vercel AI SDK's `useChat` return values:  
- `input: string` → `useChat().input`  
- `handleInputChange: (e | string) => void` → `useChat().handleInputChange`  
- `handleSubmit: (e?, chatRequestOptions?) => void` → `useChat().handleSubmit`  
- `isLoading: boolean` → `useChat().isLoading`  
Textarea autosizing is provided by **`react-textarea-autosize`**. A microphone button triggers `useConciergusVoiceInput`, which uses `window.SpeechRecognition`; transcribed text is pushed into `useChat().setInput()`.

**3.5 `<ConciergusToolUIRenderer />`**  
- Renders function-calling UI defined in `message.ui` or `message.tool_calls`.  
- Patterns for buttons, forms, carousels.

**3.6 `<ConciergusFormRenderer />`**  
- Renders basic forms (inputs, selects) based on LLM-defined form schema.  
- Submits form data back via `useChat` function call.

## 4. Backend Interaction & Retrieval-Augmented Generation (RAG)
- Documentation for Next.js API route integrating Vercel AI SDK for streaming chat.  
- Example: Query vector store (Supabase pgvector) for relevant context.  
- Show function calling examples: web search (Exa), calendar booking (Cal.com), lead submission.  
- Emphasize secure handling of API keys and data sources.

## 5. Advanced Features (Integrated into FOSS v1.0)
**5.1 Voice Chat (STT & TTS)**  
• **STT (User Input)** – `useConciergusVoiceInput` employs `window.SpeechRecognition` for real-time transcription, updating `useChat().setInput()`. If unsupported, a graceful fallback UI appears. If `onProcessRecordedAudio` is supplied, the hook records via `MediaRecorder`, posts the blob to the developer's STT service, and pipes the returned text into chat.

• **TTS (Assistant Output)** – When a new assistant message arrives and TTS is enabled, `useConciergusTTS` fetches audio from `ttsApiEndpoint` (configured via `ConciergusProvider`). The hook streams playback with controls (pause, replay, stop). If the fetch fails or no endpoint is set, an optional low-fidelity `window.speechSynthesis` fallback can be used. Developers may fully override via `onTextToAudio?: (text) => Promise<string | Blob>`.

**5.2 AI Personality Customization**  
- Support `initialMessages` (system prompt) for persona.  
- Documentation on crafting prompts for brand voice and context.

**5.3 Rich Media Responses**  
- Support images, carousels, attachments in `ConciergusMessageItem`.  
- Download links/previews for generative content.

**5.4 Lead Capture Forms/Surveys**  
- `<ConciergusFormRenderer />` for LLM-defined forms and field validation.

**5.5 Proactive Engagement**  
- `useProactiveEngagement({ rules })` hook for triggers (scroll, time, focus).  
- Example rule configurations in docs.

**5.6 Enhanced Multi-Language Support**  
- All internal labels configurable via props or i18n context.  
- RTL layout examples.

**5.7 Human Handover**  
Conciergus emits `onHandoverRequired(chatData: { messages: Message[]; lastUserMessage?: Message; toolInvocation?: ToolInvocation })` when a Vercel AI SDK tool call signals that a human agent should take over.

**5.8 Generative Content Attachments**  
- Render download links, previews for attachments or generated files.

## 6. Styling & Customization
- Unstyled by default.  
- Example styles in Tailwind CSS, plain CSS, CSS-in-JS.  
- Optional default theme CSS variables file for quick start.

## 7. Documentation & Developer Experience
- **README.md** (v1.0): Robust quick-start guide leveraging Vercel AI SDK `useChat`, core Conciergus components, styling hooks, and a clear Vercel AI SDK-compatible backend endpoint example.  
- **Post-v1.0 Docs**: Storybook for component playground; Docusaurus/Nextra for interactive guides and API reference.  
- **Contribution Guide**: Code of Conduct, governance, how to contribute.  
- Clear TSDoc comments on all public APIs.

## 8. Build, Packaging, Versioning, CI/CD, Testing
- **Bundler**: Rollup with CommonJS & ESM builds, tree-shaking.  
- **Package Management**: pnpm.  
- **Peer Dependencies**: `react`, `react-dom`.  
- **Direct Dependencies**: `@ai-sdk/react`, `ai`, requisite Radix UI packages, `@babel/runtime`, `react-markdown`, etc.  

## 9. Non-Functional Requirements
- **Performance**: Minimal Conciergus core bundle size (target < 15 KB gzipped, excluding direct dependencies); leverages Vercel AI SDK streaming optimisations and lazy-loads optional features.  
- **Accessibility**: WCAG AA via Radix UI ARIA roles; screen reader support.  
- **Security**: All Markdown is sanitized via `rehype-sanitize` to prevent XSS. Documentation emphasises that securing data sources and backend endpoints is the developer's responsibility.  
- **Error Handling**: Conciergus surfaces categorised errors (e.g., `ttsApiFailure`, `sttPermissionDenied`) through the `error` object from `useChat` or via a library-specific error context. All error types and codes will be documented so developers can build tailored UI reactions.

## 10. Future Considerations (Post v1.0)
- Visual flow builder for proactive rules.  
- Plugin marketplace for third-party integrations.  
- Built-in RAG adapters & connectors (e.g., Elasticsearch).  
- Web component packaging for non-React frameworks.
</PRD> 